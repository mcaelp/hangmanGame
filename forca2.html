<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Forca Multiplayer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; display: flex; justify-content: center; align-items: center;
      padding: 20px;
    }
    .container { background: white; border-radius: 20px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 800px; width: 100%; }
    h1 { text-align:center; color:#667eea; margin-bottom:30px; font-size:2.5em; }
    .setup-screen, .game-screen { display:none; }
    .setup-screen.active, .game-screen.active { display:block; }
    .btn-group { display:flex; gap:15px; justify-content:center; margin:20px 0; }
    button { background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:white; border:none; padding:15px 30px; border-radius:10px; font-size:1.1em; cursor:pointer; transition: transform .2s, box-shadow .2s; }
    button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102,126,234,0.4); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    input { width:100%; padding:15px; border:2px solid #667eea; border-radius:10px; font-size:1em; margin:10px 0; }
    .game-code { background:#f0f0f0; padding:20px; border-radius:10px; text-align:center; margin:20px 0; }
    .game-code-display { font-size:2em; font-weight:bold; color:#667eea; letter-spacing:5px; }
    canvas { border:3px solid #667eea; border-radius:10px; display:block; margin:20px auto; background:white; }
    .word-display { text-align:center; font-size:2.5em; letter-spacing:10px; margin:20px 0; font-weight:bold; color:#333; }
    .keyboard { display:grid; grid-template-columns: repeat(auto-fit, minmax(40px, 1fr)); gap:8px; margin:20px 0; }
    .key { padding:15px; background:#667eea; color:white; border:none; border-radius:8px; font-size:1.2em; cursor:pointer; transition:all .2s; }
    .key:hover:not(:disabled) { background:#764ba2; transform:scale(1.05); }
    .key:disabled { background:#ccc; cursor:not-allowed; }
    .status { text-align:center; padding:15px; border-radius:10px; margin:20px 0; font-size:1.2em; }
    .status.waiting { background:#fff3cd; color:#856404; }
    .status.playing { background:#d4edda; color:#155724; }
    .status.won { background:#d1ecf1; color:#0c5460; }
    .status.lost { background:#f8d7da; color:#721c24; }
    .info { text-align:center; color:#666; margin:10px 0; }
    .copy-btn { background:#28a745; padding:10px 20px; font-size:.9em; margin-top:10px; color:white; border:none; border-radius:8px; cursor:pointer; }
  </style>
</head>
<body>
  <div class="container">
    <h1>🎮 Forca Multiplayer</h1>

    <div class="setup-screen active">
      <div class="btn-group">
        <button onclick="createGame()">Criar Jogo</button>
        <button onclick="showJoinScreen()">Entrar no Jogo</button>
      </div>

      <div id="createScreen" style="display:none;">
        <h2 style="text-align:center; margin:20px 0;">Criar Novo Jogo</h2>
        <input type="text" id="wordInput" placeholder="Digite a palavra secreta" maxlength="30" />
        <div class="btn-group">
          <button onclick="startHosting()">Começar</button>
          <button onclick="cancelSetup()">Cancelar</button>
        </div>
      </div>

      <div id="joinScreen" style="display:none;">
        <h2 style="text-align:center; margin:20px 0;">Entrar em um Jogo</h2>
        <input type="text" id="codeInput" placeholder="Digite o código do jogo" />
        <div class="btn-group">
          <button onclick="joinGame()">Entrar</button>
          <button onclick="cancelSetup()">Cancelar</button>
        </div>
      </div>
    </div>

    <div class="game-screen">
      <div id="gameCode" class="game-code" style="display:none;">
        <p>Código do Jogo:</p>
        <div class="game-code-display" id="codeDisplay"></div>
        <button class="copy-btn" onclick="copyCode()">📋 Copiar Código</button>
        <p class="info">Compartilhe este código com seu amigo</p>
      </div>

      <div id="status" class="status waiting">Aguardando outro jogador...</div>

      <canvas id="hangman" width="300" height="350"></canvas>

      <div class="word-display" id="wordDisplay"></div>

      <div class="info">
        <p>Erros: <span id="mistakes">0</span> / 6</p>
      </div>

      <div class="keyboard" id="keyboard"></div>

      <div class="btn-group">
        <button onclick="newGame()">Novo Jogo</button>
        <button onclick="backToMenu()">Menu</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('hangman');
    const ctx = canvas.getContext('2d');

    let gameState = {
      word: '',
      displayWord: '',
      guessed: [],
      mistakes: 0,
      gameCode: '',
      isHost: false,
      connected: false,
      won: false,
      lost: false
    };

    let peer = null;
    let conn = null;

    // UI helpers
    function createGame() {
      document.getElementById('createScreen').style.display = 'block';
      document.getElementById('joinScreen').style.display = 'none';
    }
    function showJoinScreen() {
      document.getElementById('joinScreen').style.display = 'block';
      document.getElementById('createScreen').style.display = 'none';
    }
    function cancelSetup() {
      document.getElementById('createScreen').style.display = 'none';
      document.getElementById('joinScreen').style.display = 'none';
    }

    // HOST: start
    function startHosting() {
      const word = document.getElementById('wordInput').value.toUpperCase().trim();
      if (!word || word.length < 2) { alert('Digite uma palavra com pelo menos 2 letras'); return; }

      gameState.word = word;
      gameState.isHost = true;

      const peerId = 'forca-' + Math.random().toString(36).substr(2, 9);
      peer = new Peer(peerId);

      peer.on('open', (id) => {
        gameState.gameCode = id;
        document.querySelector('.setup-screen').classList.remove('active');
        document.querySelector('.game-screen').classList.add('active');
        document.getElementById('gameCode').style.display = 'block';
        document.getElementById('codeDisplay').textContent = id;
        updateStatus('Aguardando outro jogador...', 'waiting');
        initGame(); // host initializes (keyboard hidden for host)
      });

      peer.on('connection', (connection) => {
        conn = connection;
        setupConnection();
        conn.on('open', () => {
          gameState.connected = true;
          updateStatus('🎮 Jogo em andamento!', 'playing');
          // send initial masked state to guest
          sendGameState();
        });
      });

      peer.on('error', (err) => { console.error(err); alert('Erro PeerJS: ' + err.type); });
    }

    // GUEST: join
    function joinGame() {
      const code = document.getElementById('codeInput').value.trim();
      if (!code) { alert('Digite um código válido'); return; }

      gameState.isHost = false;
      gameState.gameCode = code;
      peer = new Peer();

      peer.on('open', () => {
        conn = peer.connect(code);
        setupConnection();

        conn.on('open', () => {
          gameState.connected = true;
          // show screens and create keyboard for guest
          document.querySelector('.setup-screen').classList.remove('active');
          document.querySelector('.game-screen').classList.add('active');
          createKeyboard(); // ensure guest has keyboard clickable
          document.getElementById('keyboard').style.display = 'grid';
          updateStatus('Conectado! Aguardando palavras do host...', 'waiting');
        });
      });

      peer.on('error', (err) => { console.error(err); alert('Erro ao conectar: ' + err.type); });
    }

    function setupConnection() {
      if (!conn) return;
      conn.on('data', (data) => handleMessage(data));
      conn.on('close', () => {
        gameState.connected = false;
        updateStatus('⚠️ Conexão perdida', 'lost');
      });
    }

    function sendMessage(msg) {
      if (conn && conn.open) conn.send(msg);
    }

    // Message handling (both sides)
    function handleMessage(msg) {
      switch (msg.type) {
        case 'guess':
          // Host processes guesses from guest
          if (gameState.isHost) {
            processGuess(msg.letter);
          }
          break;

        case 'update':
          // Guest receives updated masked word + state
          gameState.displayWord = msg.displayWord;
          gameState.guessed = msg.guessed;
          gameState.mistakes = msg.mistakes;
          updateGameState();
          break;

        case 'gameover':
          // Both sides handle gameover display (host sends when appropriate)
          gameState.displayWord = msg.displayWord;
          endGame(msg.won);
          break;
      }
    }

    // Game logic
    function initGame() {
      gameState.guessed = [];
      gameState.mistakes = 0;
      gameState.won = false;
      gameState.lost = false;
      // For host, build masked display from real word
      if (gameState.isHost) {
        gameState.displayWord = gameState.word.split('').map(ch => ch === ' ' ? ' ' : '_').join('');
      } else {
        gameState.displayWord = ''; // guest will get update from host
      }

      drawHangman();
      updateWordDisplay();
      createKeyboard();

      // If host: hide keyboard (host shouldn't click letters)
      if (gameState.isHost) {
        document.getElementById('keyboard').style.display = 'none';
      } else {
        document.getElementById('keyboard').style.display = 'grid';
      }

      updateMistakes();
    }

    function guessLetter(letter) {
      // guest sends guess to host
      if (!gameState.connected || gameState.won || gameState.lost) return;
      if (gameState.guessed.includes(letter)) return;
      sendMessage({ type: 'guess', letter });
      // optionally disable immediately to avoid double send until update arrives:
      // disable the clicked button now:
      const buttons = document.querySelectorAll('.key');
      buttons.forEach(btn => {
        if (btn.textContent === letter) btn.disabled = true;
      });
      // we don't update guessed/mistakes locally for guest — host will send authoritative state
    }

    function processGuess(letter) {
      // run on host
      if (gameState.guessed.includes(letter)) return;
      gameState.guessed.push(letter);

      if (!gameState.word.includes(letter)) {
        gameState.mistakes++;
      }

      // rebuild masked display
      const masked = gameState.word.split('').map(ch => {
        return (ch === ' ' ? ' ' : (gameState.guessed.includes(ch) ? ch : '_'));
      }).join('');

      gameState.displayWord = masked;

      // send updated state to guest
      sendGameState();

      // check win/lose and send gameover if needed
      if (!masked.includes('_')) {
        // host win (guest guessed all)
        endGame(true);
        sendMessage({ type: 'gameover', won: true, displayWord: gameState.word });
      } else if (gameState.mistakes >= 6) {
        // guest lost
        endGame(false);
        sendMessage({ type: 'gameover', won: false, displayWord: gameState.word });
      } else {
        // just update host UI (host can see masked for verification)
        updateGameState();
      }
    }

    // send the authoritative state (host -> guest)
    function sendGameState() {
      if (!conn || !conn.open) return;
      sendMessage({
        type: 'update',
        displayWord: gameState.displayWord,
        guessed: gameState.guessed,
        mistakes: gameState.mistakes
      });
    }

    // UI update functions
    function updateGameState() {
      drawHangman();
      updateWordDisplay();
      updateKeyboard();
      updateMistakes();
    }

    function drawHangman() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 3;

      // base / pole
      ctx.beginPath();
      ctx.moveTo(50, 330);
      ctx.lineTo(150, 330);
      ctx.moveTo(100, 330);
      ctx.lineTo(100, 50);
      ctx.lineTo(200, 50);
      ctx.lineTo(200, 80);
      ctx.stroke();

      const m = gameState.mistakes;
      if (m > 0) { ctx.beginPath(); ctx.arc(200, 100, 20, 0, Math.PI*2); ctx.stroke(); }
      if (m > 1) { ctx.beginPath(); ctx.moveTo(200, 120); ctx.lineTo(200, 200); ctx.stroke(); }
      if (m > 2) { ctx.beginPath(); ctx.moveTo(200, 140); ctx.lineTo(170, 170); ctx.stroke(); }
      if (m > 3) { ctx.beginPath(); ctx.moveTo(200, 140); ctx.lineTo(230, 170); ctx.stroke(); }
      if (m > 4) { ctx.beginPath(); ctx.moveTo(200, 200); ctx.lineTo(170, 250); ctx.stroke(); }
      if (m > 5) { ctx.beginPath(); ctx.moveTo(200, 200); ctx.lineTo(230, 250); ctx.stroke(); }
    }

    function updateWordDisplay() {
      const out = (gameState.isHost ? gameState.displayWord : gameState.displayWord || '')
        .split('').join(' ');
      document.getElementById('wordDisplay').textContent = out;
    }

    function createKeyboard() {
      const keyboard = document.getElementById('keyboard');
      keyboard.innerHTML = '';
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let ch of letters) {
        const btn = document.createElement('button');
        btn.className = 'key';
        btn.textContent = ch;
        btn.onclick = () => guessLetter(ch);
        keyboard.appendChild(btn);
      }
      updateKeyboard();
    }

    function updateKeyboard() {
      document.querySelectorAll('.key').forEach(btn => {
        if (gameState.guessed.includes(btn.textContent)) btn.disabled = true;
        else btn.disabled = false;
      });
    }

    function updateMistakes() {
      document.getElementById('mistakes').textContent = gameState.mistakes;
    }

    function updateStatus(text, type = 'waiting') {
      const s = document.getElementById('status');
      s.className = 'status ' + type;
      s.textContent = text;
    }

    function endGame(won) {
      gameState.won = won;
      gameState.lost = !won;
      if (won) updateStatus('🎉 Parabéns! Você venceu!', 'won');
      else updateStatus(`😢 Você perdeu! A palavra era: ${gameState.word}`, 'lost');

      document.querySelectorAll('.key').forEach(k => k.disabled = true);
    }

    function copyCode() {
      navigator.clipboard.writeText(gameState.gameCode).then(() => alert('Código copiado!'));
    }

    function newGame() {
      if (!confirm('Iniciar um novo jogo? (Isso encerrará a conexão atual)')) return;
      if (conn) conn.close();
      if (peer) peer.destroy();
      backToMenu();
    }

    function backToMenu() {
      if (conn) conn.close();
      if (peer) peer.destroy();

      document.querySelector('.game-screen').classList.remove('active');
      document.querySelector('.setup-screen').classList.add('active');
      document.getElementById('gameCode').style.display = 'none';
      document.getElementById('wordInput').value = '';
      document.getElementById('codeInput').value = '';
      cancelSetup();

      gameState = {
        word: '',
        displayWord: '',
        guessed: [],
        mistakes: 0,
        gameCode: '',
        isHost: false,
        connected: false,
        won: false,
        lost: false
      };

      document.getElementById('keyboard').innerHTML = '';
    }

    // Helpful: if the host closes the page, guest sees lost when connection closes (handled above).
  </script>
</body>
</html>
